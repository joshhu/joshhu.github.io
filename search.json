[{"title":"李開復先生的世代說有何問題？","url":"/2017/06/20/lkf/","content":"# 前言\n李開復博士在他的fb上有[一篇探論人工智慧在台灣發展的文章](https://www.facebook.com/kaifulee/posts/1670663686294276)，談到ICT(Information and Communication Technology)的世代交替分別如下：\n\n> ICT高科技朝代迭代是快速，有週期，有連續性。從**半導體->PC->軟體->Internet->社交->行動->大數據->AI**\n\n我個人覺得這個分法有點不倫不類，把世代和服務混為一談的確有點**張飛打岳飛**。\n\n根據Jim Gray 2003年在[The Fourth Paradigm: Data-Intensive Scientific Discovery](http://www.immagic.com/eLibrary/ARCHIVES/EBOOKS/M091000H.pdf)這本書中的說法，ICT工業的出現不過就這幾十年，而這幾十年間，ICT工業向前進的動力就是運算(Computation)。\n\n根據Jim Gray的說法，Computation是第三代範式，運算就是這個範式的基礎。當然運算一直是以半導體(硬體)的運算能力為代表，因此從半導體開始的世代交替，是離不開硬體的。\n![](https://static01.nyt.com/images/2009/12/15/science/15books-1/popup.jpg)\n# 第三代範式中的世代\n\n然而李博士所提到的軟體、社交等，充其量只是附隨在運算這個範式中，每一個世代所伴隨而來的無形服務而已。我覺得在第三範式中，世代交替應該以運算為主軸，因此我個人的看法是：\n\n** 半導體->PC->網際網路->行動->雲端**\n\n而在這些不同的世代中，伴隨「運算」核心而產生的服務應該就是：\n\n** 專屬軟體(半導體)->軟體(PC)->網站(網際網路)->APP(行動)->O2O(雲端)**\n\n整理如下表：\n\n|世代 |   運算(硬體，有形) |   服務(軟體，無形)|\n|-----|-----|-----|\n|半導體 |   半導體 |       專屬軟體|\n|PC |     PC   |       軟體|\n|網際網路 | 路由器/伺服器|   網站|\n|行動|    行動裝置    | APP|\n|雲端|    集群運算能力及終端 | O2O|\n\n世代交替並非取代而是包容，新的世代當然包容了舊的世代，這和新的範式包容舊範式的意義完全一樣。\n\nPC世代將專屬軟體吃掉，成為開放軟體平台，PC並非讓半導體消失，而是更發揚了半導體的功能。\n\n網際網路並非讓PC消失，而是讓PC成為網路終端的一部分，網站當然也沒有讓軟體消失，而是讓軟體成為HTTP或其它協議交匯的一個點。\n\n當然行動世代也沒有讓網際網路世代消失，而是讓固定在機房中的網站和伺服器，成為行動網路中的一個「不行動」的點。\n\n雲端世代當然包括了行動世代，所對應的就是O2O的服務充斥。君不見UBER、TURO這種將有形無形資源平均到每一個角落的新式服務，當然就是靠線上的伺服器(雲端)以及線上的行動裝置及人類合理完成的。\n\n# 回到李開復先生的論點\n\n軟體是PC產業所創造出來的無形服務，他並沒有取代或包容PC成為一個新的世代，沒有PC軟體怎麼可能存活？當時的Wintel說法，再再證明PC和軟體互為依附生存。\n\n另外社交當然是網際網路世代所產生的服務之一(網站)。早在行動裝置出來之前，FB就開始流行了，FB當然是依附在HTTP協定上的一個服務(就算行動裝置出來也一樣)，他並沒有取代網際網路世代。\n\n另外從行動跳到大數據，也有點唐突，因為中間還有一個世代就是雲端。雲端代表著虛擬化的極緻，當軟體離開硬體可在任意機器上運行(軟體的虛擬化)；當作業系統離開硬體可在任意機器上運行，並且透過網路傳回運算結果時，我們可以說硬體本身已經離開硬體本身了，而硬體竟然具有加減乘除出現消失的特性(Amazon EC2, Google Compute Engine)時，雲端的概念才逐漸成形。\n\n而Hadoop MR或YARN的出現，再再告訴我們叢集運算(可加疊運算)，正是為了處理下一代大數據在作準備，只是，這次不再是在範式間的世代交替，而是正式進入了範式轉換(Paradigm Shift)。我們即將從第三範式的運算，正式進入了第四範式的Data exploration。\n\n# 即將進入第四代範式的第一世代\n\n![](paradigm.jpg)\n此時，李開復先生所謂的ICT將不復存在，取而代之的則是所謂的DT( Data Technology)，而在第四代範式中，所出現的第一個世代，就是大數據世代。那麼伴隨大數據世代的第一個無形服務，自然就是李先生所提的人工智慧。\n\n\n|世代 |   運算(硬體，有形) |   服務(軟體，無形)|\n|-----|-----|-----|\n|大數據 |   雲端及叢集 |     人工智慧|\n\n因此我覺得正確的分法，應該是\n\n\n**第三代範式**\n\n|世代 |   運算(硬體，有形) |   服務(軟體，無形)|\n|-----|-----|-----|\n|半導體 |   半導體 |       專屬軟體|\n|PC |     PC   |       軟體|\n|網際網路 | 路由器/伺服器|   網站|\n|行動|    行動裝置    | APP|\n|雲端|    集群運算能力及終端 | O2O|\n\n\n**第四代範式**\n\n|世代 |   運算(硬體，有形) |   服務(軟體，無形)|\n|-----|-----|-----|\n|大數據 |   雲端及叢集 |     人工智慧|\n\n\n"},{"title":"Rails用ajax call作表單即時驗證(ajax and json)","url":"/2017/06/20/jsonResponse/","content":"# 前言\n\n在許多網站註冊時，你會發現如果輸入「使用者名稱」或「電子郵件」時，不需要按下「送出」按鍵，只要你離開該輸入欄位時，就會自動跳出「使用者已存在」之類的提示。這個功能可以即時檢查，速度快又夠體貼，一樣也是用ajax call來做，我們就來看看詳細作法。\n\n# 環境設定\n\n## 系統設定\n\n* Rails 4.2.6\n* Ruby 2.3.0\n* Mac OS Sierra\n\n## Rails設定\n\n* 有一個User model, 其中有一個id欄位。\n\n# 程式說明\n\n## 路由設定\n\n首先我們在`routes.rb`中先定義好`user`的路由，主要是這一行：\n\n```ruby\nget 'users/check', to: 'users#check', as: 'userCheck'\n```\n\n這一行主要的目的就是把userCheck這個路徑導到`users_controller.rb`中的`check`這個action，這可以讓controller更加簡單，只要一有個action就行。\n\n## Controller\n\n接下來看controller。\n\n```ruby\n# app/controller/users_controller.rb\nclass UsersController < ApplicationController\n  def check\n    @user = User.find_by(uid: params[:uid])\n    respond_to do |f|\n      f.html\n      f.json {render json: (@user.present?)? @user.lcname.to_json : \"Not exist\".to_json}\n    end\n  end\nend\n```\n\n** 說明 **\n\n程式很簡單，就只有`check`這個action而已。第4行就是讀取使用者輸入的使用者id，使用`params[:uid]`來讀取使用者的輸入。如果是一開始載入頁面，自然就沒有這個id。\n\n第5-7行非常重要，這邊用到`respond_to`這個rails的指令。\n\n首先如果系統是正常進來，就是使用者打了`http://192.168.1.105:3000/users/check`的話，則伺服器應該就會傳回html，也就是我們看到的頁面, 你可以試著輸入`http://192.168.1.105:3000/users/check.html`，可以發現是指到同一個頁面，這是因為rails在伺服器端丟一個check.html回去給瀏覽器。\n\n第二個情況就是瀏覽器(不是使用者)利用ajax call要求json資料時，我們必須也要有所回應，因此就有第7行的程式碼，針對要求ajax call的回應，等一下會在view中詳細說明。\n\n這邊第7行很簡單，表示，如果碰到了ajax call並且要求json，則傳回json格式的資料(即`render json`)。這也就是為什麼後面的`@user.lcname`和單純的字串`\"Not exist\"`都要利用`.to_json`的方法先轉換成json格式才能傳回使用者的瀏覽器。這個轉換的過程稱之為**「序列化」(Serlization)**。\n\n你可以試著輸入`http://192.168.1.105:3000/users/check.json`，就會發現下圖的畫面，表示我們要求了json的資料，但是因為找不到對應的`@user`，所以就會走到第7行程式後面的`\"Not exist\"`。第7行程式碼後端是一個三元運算子，利用`@user.present?`這個方法來檢查資料庫中這個使用者是否存在。如果存在就傳回使用者的名稱`@user.lcname`，不存在就傳回一個`\"Not exist\"`的字串。\n![](notexist.jpg)\n\n## View\n\n程式的重點在view，我們就來看看\n```javascript\n// app/views/users/check.html.erb\n<h1>Users#check</h1>\n<%=text_field_tag :uid, nil, id: \"input_user\" %><br><br>\n<div id='warningMessage'><div>\n<script>\n  $(\"#input_user\").blur(function onInputBlur(){\n    value = $(this).val();\n    if (value.trim().length > 0){\n      $.ajax({\n        url: \"<%= userCheck_path(:json) %>\",\n        type: 'GET',\n        datatype: \"json\",\n        data: {uid: $(this).val() },\n        error: function(){\n          console.log(\"error\");\n        },\n        success: function(data){\n          if(data != \"Not exist\"){\n            $(\"#input_user\").val(\"\");\n            $(\"#warningMessage\").html(\"使用者\"+data+\"已存在\");\n        }\n          console.log(data);\n        }\n      });\n    }\n  })\n  $(\"#input_user\").focus(function onInputFocus(){\n    //this.value=\"\";\n      $(\"#warningMessage\").html(\"\");\n   })\n</script>\n```\n\n** 說明**\n\n第3行使用了rails的`text_field_tag`這個helper來讓使用者輸入，輸入的值放在`uid`中。我們在這邊要定義一個DOM的id值`\"input_user\"`，因為這個值會改變。\n\n第4行我們定義了一個顯示訊息的部分，等一下會在輸入欄下方有訊息顯示使用者是否存在。\n\n接下來就是主程式。這邊使用了一個javascript的`blur`function。表示如果使用者輸入完離開這個文字框，就會綁定一個事件，綁定的事件就是7到26行。首先我們先用第8行排除使用者輸入的空格，重點就是第9號開始。如果使用者輸入後，我們在第7行取得輸入資料，呼叫伺服器器上的`userCheck_path`(第10行)，並且規定用json格式，這樣子controller才會去render json格式的資料。使用的RestFUL方法為`GET`(第11行的type), 使用的資料格式為json(第12行)，傳回的值為使用者輸入的`uid`(第13行)。\n\n如果ajax call錯誤就在console印出\"error\"(第15行)。如果成功，就執行17-21行。\n\n在第18行判斷是否有找到，如果找到了，表示這個使用者存在，因此我們在第19行把輸入的文字欄清空，並且在20行，在文字欄下方顯示「使用者xx已存在」。其中`xx`正是伺服器傳回來的`@user.lcname`的json格式姓名。\n\n第22行是列出使用者姓名或是\"Not exist\"方便偵錯，第27-29行則是當使用者再度回到輸入欄時，會把輸入欄下方原來「使用者xx已存在」的訊息清掉。\n\n\n這樣一來，我們就可以透過ajax call+json，在真正送出資料到後端伺服器之前就檢查使用者是否存在，讓表單的驗證更方便也更人性化：\n\n# 整個完整流程\n\n接下來是整個完整流程\n\n1. 使用者在瀏覽器中輸入`http://192.168.1.105:3000/users/check`，就是在向後端的伺服器發出GET HTTP。\n2. 伺服器檢查使用者的請求，去查routes是否存在這個請求。\n3. 伺服器發現這個請求對應的是`users#check`這個action，因此執行這個action中的動作。\n4. 執行`check`這個action之後，把變數代表的值丟到對應的template `check.html.erb`中\n5. `check.html.erb`把變數代表的值換掉其中的變數，成為`check.html`。\n6. `check.html`傳回使用者瀏覽器執行。一開始使用者沒有輸入，因此`@user`是不存在。\n7. 使用者在瀏覽器中輸入一個id，並且離開輸入欄位(用滑鼠或是按下tab鍵)\n8. 此時觸發了`'#input_user'`這個id的blur事件，在使用者的瀏覽器上執行ajax call\n9. 根據ajax call的參數，發現是一個GET事件，因此根據參數值去伺服器端\n10. 伺服器端接到ajax GET的要求，去routes找，發現是`users_controller`中的`check`這個action。\n11. 此action接收了ajax參數中的`uid`值，找到使用者`@user`。\n12. 找到的話，就取出`@user.lcname`，並且把這個字串轉換成json，傳回瀏覽器。\n13. 找不到，就把\"Not exist\"這個字串轉換成json傳回瀏覽器。\n14. 使用者瀏覽器接收到資料，如果是找到，就在一個div中顯示使用者已存在，並且將原來的輸入欄清空。\n15. 如果沒找到，就不顯示任何訊息，讓使用者繼續。\n\n\n![](jsonresponse.gif)\n\n我們可以從上圖中看到從伺服器傳回來的值，就是完整的一段script，並且把其中的html都更新成城市了。\n\n\n","tags":["javascript"]},{"title":"為什麼要學程式設計(一）？","url":"/2017/06/19/learnToCode1/","content":"**TL;DR: 變更聰明，更加方便，機會更多，賺更多錢，更多朋友**\n\n# 前言\n\nJobs說過：「每個人都必須學程式設計，它可以幫助你思考」。大多數人覺得程式設計(Programming)是程式設計師的專業，這個觀念是完全錯誤的，8成以上的程式設計師在大學不是學程式設計的，4成以上的程式設計師大學讀的根本不是理工。那麼程式設計到底有什麼用？難不難？怎麼學？學哪一種？怎麼開始？這些看起來很麻煩的議題，其實一點也不難，你只要找到入口點，接下來就很容易了。\n\n# 是一個專業嗎？\n\n程式設計就像修車、木工、拉小提琴一樣，它可以是一個興趣，也可以是一個專業，從而讓你獲得快樂，賺些零用錢或發大財，視你下的功夫有多深而定。但程式設計和修車、木工、拉小提琴不同的是，其上手容易，學習簡單，而且前面的路非常寬廣。\n\n你可以自己設計一個資料庫來管理硬碟中下載的電影(興趣)，也可以設計網頁讓自己一個月多個兩三萬的零用錢(兼差)，也可成為專業的Freelancer開發人員，這個收入絕對比22K多上好幾倍，前題是你要接得到案子(收入)；當然如果你功力夠，英文又好，你可以到矽谷找工作，年收入十幾萬美金起跳是常有的事(職業)。當然你如果心中有很棒的創業點子，你也不需要到處找人幫你設計網站或APP，你自己就可以設計出一個原型去找投資人，當然完整的產品可能需要一個團隊(發財)。\n\n數位時代造就了許多富翁，耳熟能詳的微軟Bill Gates、臉書Mark Zuckerberg、Google的Larry Page和Sergie Brin、亞馬遜的Jeff Bezos、甲骨文的Larry Ellison都是程式設計師出身，除了軟體業，真實版鋼鐵人Elon Musk也是程式設計師出身，如果你志比天高，你也可以和他們一樣，他們這輩子的第一個產品，絕對不是外包出去，而是自己一行一行開發出來的，更不要說上述的名人大部分從高中開始就在寫程式賺零用錢了。\n\n# 有哪些出路\n\n## 生活上的便利\n\n就像前面說的，如果你只是興趣，你可以解決很多生活上的不便利。當別人還守在電腦前準備搶購最新的iPhone時，你早就寫好程式在睡大頭覺，用電腦幫你搶了；當別人還在用複製/貼上去交友網站留言時，你早就用程式把全交友網站所有介於18-24歲，身高150-170的女生全部都發了一封信。你用程式可以免人工做到很多重複性高、需要消耗大量輸入及計算的事情，何樂而不為？省時方便又快樂。\n\n## 網頁(前端)/網站(後端)工程師\n\n如果你想賺點小錢，你可以設計網頁前端，只要熟悉HTML，CSS3、Javascript就行(除了Javascript外這些都是非常入門的語言)。\n\n如果你想設計整個網站架構，學習Rails、Node.js，Python以及對應的Framework，再加上MySQL資料庫等，就連後端也沒問題了。\n\n如你想自己架設主機，那就多學一個Amazon EC2、Google Cloud Engine、阿里雲。\n\n會了上面全部，你就成為一個全端工程師，只要和網頁、網站有關的東西你都不會有問題(當然還不會是高手)。\n\n## app工程師\n\n當然你也可以學習Java和Swift來開發Android和蘋果的手機/平板軟體，你就成為一個App的開發工程師。\n\n## 大數據\n\n大數據？沒問題，學習Python、Spark、Hadoop，再加上一些工具及演算法，你立即晉昇為新時代的大數據工程師/架構師。\n\n## 硬體工程師\n\n如果你對機器人，無人機、物聯網等設計有興趣，學習C/C++，JAVA，你可以幫設計IC、或是撰寫硬體的驅動程式或控制程式。\n\n上面所有的出路，目前全世界都極缺人，你真的就算做的只有中上水平，都能找到不錯的工作，更棒的是，如果你願意花功夫更上一層樓(和智商無關)，你的薪水當然就隨著努力增加(可能是倍增)，這種花時間學東西，就能越賺越多，為什麼不做？\n\n# 我會不會太(老小笨嫩……)？\n\n## 太老？\n\n我公司一個45歲大叔，年輕時開發過DOS及Windows應用程式，後來轉行房地產賣車什麼都做過。近年來到公司當業務，在最前線接觸客戶，深刻了解客戶的需求，發現和公司內部宅男工程師的想法天差地別，他就想說自己幹吧！從前年開始自學Rails以及前端設計，兩年來，已經幫公司完成大約20個大大小小的案子，現在自己創業去了。\n\n我爸爸八十幾歲，我大約半年前開始教他寫程式，太難的不說，至少搜尋出他自己硬碟上的資料，檢查下載的東西是否存在，設計一個網頁表單給朋友填寫是否要參加聚會，這種簡單的他都沒問題。\n\n## 太小？\n\n你應該知道歐巴馬總統早就在推行從小開始學程式；很多美國的幼稚園已經開始用玩樂的方式教導(四歲)，大部分的高等小學在一年級(七歲)已經開始教迴圈及條件判斷了。\n\n目前全世界在推STEAM(Science, Technology, Engineering, Agriculture, Mathematics，但台灣把Agriculture拿掉，改成STEM)，而要完成STEAM教學，第一件事就是程式設計。和學習自然語言一樣，學習程式語言的年紀越小越好，讓小朋友從小就有邏輯觀念，養成思考的好習慣，頭腦內部活動越頻繁的小孩一定比較聰明，這已經經過科學證實了。\n\n## 太笨？\n\n行天宮有一個很有名的算命攤的命相師是小學畢業程度，他使用自己開發紫微斗數的命盤解盤程式，我有一個修車朋友，是一個國中畢業的修車師傅搞通了整個BMW的E-SYS幫別人修改行車電腦，甚至這位修車師傅目前在台灣有很多家分店，他常常用TeamViewer連線到BMW原廠客戶的車輛上，幫原廠工程師解決他們都無法搞定的問題。\n\n從主觀的教育體制來說，他們是被歸類為「笨」的，但他們的成就，不會比名校資工系畢業差太多。\n\n很多人說學程式設計要天份，這句話也對也錯。程式設計是一門非常成熟的學科，你只要要按部就班一步一步來，就會達到一定的成就，聰明與否，只是到達這個成就時間的快慢而已，並不會永遠到不了。更棒的是，現在的程式語言都很直覺，你再聰明或再笨，到達這個時成就的時間都不會差太多，有什麼好怕的？全世界籃球天份最高的的人不出Michael Jordan、Kobe Bryant或是現役的LeBron James吧！告訴大家，這三個人的練球時間比NBA球員的平均練球間多一倍！聰明與否不重要，有沒有下功夫才是重點。\n\n## 太嫩？\n\n完全沒有基礎怎麼辦？誰一開始就有基礎的？但只要你願意花時間，下功夫，不怕難，不怕卡關，卡關一定要破關的決心，上手之後就快了。\n\n我之前在當Team Leader時，來了兩個新手，一個是北京理工學院的Benson，一個是生物系畢業的Yale。Benson基礎好，上手快，一下子就變成公司的主力，最後也昇到Team Leader。Yale只會簡單的C#，什麼都從頭來，動作也比較慢，但他也很用功，最後雖然沒有成為Team Leader，但他一直不斷自學，也自己花錢去上課，最後聽到他的消息是在微軟當工程師，現在移民到日本也是做程式設計師。反而是Benson一直用他當時的技術在做事，反而就陷在一些很瑣碎的程式設計細節上，浪費太多時間。\n\n程式設計這行業最棒的地方，就是你可以零基礎起步。前面提到的幾個名人，很多不是程式設計師科班出身，只要你識字，有一點英文及數學基礎，加上一台能上網的電腦就可以開始了。\n\n現在要學程式設計連課都不用上，甚至連書都不用買，有許多免費的課程，甚至是大學都有MOOC(免費線上課程)可上，只要你想開始，隨時都可以開始。\n\n# 會很難嗎？\n\n當然難，除了吃飯睡覺什麼不難？當木匠難嗎？拍電影難嗎？玩電動難嗎？學修車難嗎？但學程式設計你唯一要做的，就是坐在電腦前面把很多事情的脈略找出來，你不需要上街，不需要用力，你唯一要用的就是腦和手，和很多同酬的事情比較起來，程式設計反而相對簡單。\n\n## 痛苦嗎？\n\n程設計就像從河的這岸架橋到另一岸上。你知道目標是什麼，達成目標的方法也有很多種，但是你需要知道河中哪裏可以打椿，打好椿之後怎麼樣開始架龍骨，龍骨架好後怎麼鋪路，一點一點開始，一點一點進步，一點一點完成，失敗就退回上一次成功的地方，成功就繼續向下走，中間百分之一萬會出問題，出問題是常態，解決問題才是整個過程的重點。\n\n一開始寸步難行，什麼都做不出來。照著書上或網上的做，噴出一大堆錯誤訊息，旁邊的人一下就出來的東西，你就是做不出來。是網上的寫錯了還是我做錯了？為什麼我的環境就是不行？你會氣自己，氣網站，甚至砸東西(我砸過鍵盤)，然後氣的發誓再也不學了。\n\n## 不放棄的禮物\n\n小心小心！這就是99%的人放棄的點。你在這邊放棄，就永遠放棄了。程式設計當然難，不難的話誰都會，撐過去的就是你的，這一個坎過了就是過了。沒有過不了的關，沒有解決不了的問題，有時得退回原點重新設計，但最終，只要你一心一意要完成，一定會完成的。當你過了一關，就是輕鬆的下坡了(當然馬上就會遇到另一個上坡)。\n\n你會常常卡關想放棄，但有時靈機一動又破關繼續向前走。你會利用腦中現存的知識來做出你沒做過的事，當你發現新知識時，你腦中的工具又多了一樣。發現新知識的方法很多，你只有不斷讓自己一直學新東西，你手上的武器才會越來越多，當你手上的武器夠多時，很多簡單的問題用一樣武器就攻克，而不需要多樣武器，你會覺得速度越來越快，東西越做越好，很多原來很難的地方都迎刃而解，學一個新技術就兩三小時，學一個新的語言就兩三週，這時你還是會重複一樣的步驟，卡關，破關，不斷前進，不斷進步，最後發現大家都來找你問問題，都來找你幫他做事，儘管你還是覺得自己很爛。\n\n## 過程和結果很快樂\n\n你永遠不會覺得自己很厲害，永遠都覺得什麼都不懂，這時你才發現Jobs說的「Stay hungry, stay foolish」不是刻意保持低調，而是一種真實的感受。但是當你發現自己愚笨的頭腦竟然也做出了漂亮的結果時，不經意的拍手叫好，歡呼震天是常有的事。\n\n所以難才好玩，不難有什麼意思？越難越好玩，我每次學一個新東西，就希望他越難越好，難表示世界上會的人少，我的機會才多；難表示挑戰大，成就感才大；難表示門檻高，要進來和我競爭的人不會多，我才顯得更有價值。所以程式設計當然很難，但當你了解箇中奧秒時，你會發現難才是好事。\n\n再難再苦，你再沒興趣，卡關再想殺人，但是……\n\n* 當大家在求職網站上拼命找個22K的工作時，是工作拼命找上你\n* 當你每個月比同時畢業的同學多賺好幾倍\n* 當大家開Toyota時你開BMW\n* 當大家在東南亞跟團跑行程時你在歐美自駕遊\n* 當大家每天打卡上班時你才準備起床去健身房\n* 當大家在辦公室勾心鬥角時你在海邊的星巴克用Mac工作\n* 當大家到處求人幫忙開發創意時，你已經做出原型在和投資人談股份分配\n\n這時候，再難再苦再累，一切都值得了，而且，你會很快樂。\n\n \n\n\n"},{"title":"Rails單頁選單顯示表單實作(三)","url":"/2017/06/13/jsresponse/","content":"# 前言\n\n雖然在上一篇[Rails單頁選單顯示表單實作(二)](http://josh.hu/2017/06/13/remoteTrue/)中我們用了rails提供的ajax call直接更新`index.html`這個網頁上`<ul div=\"show_items\">`這個元素，但是筆者一直覺得那個查詢按鈕很多餘。應該是我們選擇了國家之後，自動就要列出這個國家的城市，可以少移動一個滑鼠及少按一個按鈕，也比較直覺，我們就來看看怎麼做。\n\n# 準備工作\n\n你只要有這一篇[Rails單頁選單顯示表單實作(一)](http://josh.hu/2017/06/12/samePageForm/)中準備好的project即可，我們就先切換到新的git branch。\n```shell\ngit checkout -b jsresponse\n```\n\n# 要修改的地方\n\n這邊要修改的地方有幾個，首先就是`index.html.erb`這個view。因為我們要監測選單變更的事件，並且把選單變更的事件綁定到一個jquery的函數，因此需要給這個選單一個id。此外我們當然要把按鈕拿掉，因此`index.html.erb`就變的非常簡單了，`app/view/cities/index.html.erb`的程式如下：\n```javascript\n<h2>選擇國家</h2>\n<%= select_tag :country_id, options_from_collection_for_select(@countries, \"id\",\"name\"), id: \"filter\" %>\n\n<ul id=\"show_items\">\n  <%= render @cities %>\n</ul>\n<%= debug(params) if Rails.env.development? %>\n```\n**說明**\n\n首先就在第2行，多了一個`id: \"filter\"`，這是等一下要更動的地方，其它則維持不變。\n\n接下來我們在這個程式的最下方先暫時加一段javascript，如下：\n```html\n<h2>選擇國家</h2>\n<%= select_tag :country_id, options_from_collection_for_select(@countries, \"id\",\"name\"), id: \"filter\" %>\n\n<ul id=\"show_items\">\n  <%= render @cities %>\n</ul>\n<%= debug(params) if Rails.env.development? %>\n\n<script>\n $(\"#filter\").change(function(){\n   $.ajax({\n     url: \"<%= cities_path(:js) %>\",\n     type: 'POST',\n     datatype: \"script\",\n     data: {country_id: $(this).val() },\n     success: function(data){\n       console.log(data);\n     }\n   });\n });\n</script>\n```\n\n**說明**\n\n第9到21行是標準的javascript，用來綁定選單變動時執行的事件函數。第11到17行是這個函數的本身。\n\n首先是10行，當`#filter`這個id的選單(即第2行)有變動時，即執行第11到17行的ajax呼叫。\n\n第11到17行的是標準jquery呼叫ajax的語法，包括了幾個參數：\n* `url`: 當發生ajax call時，這邊請求的頁面寫成eruby參數的格式，如`\"<%= cities_path(:js) %>\"`。\n* `type`: `'POST'`，表示是用POST。\n* `datatype`: 我們要求伺服器傳回javascript執行，因此這邊寫`\"script\"`。如果是要資料的話，可以是`\"json\"`。\n* `data`: 這就是我們要傳回伺服器的資料，也就是rails中的`params`。這邊指定`country_id`這個值為`$(this).val()`，表示取這個選單中選中的值。\n* `success`: 這是執行ajax call成功之後的執行函數，通常就會把從伺服器傳回來的資料一起傳到這函數。我們可以用一個`console.log`來印出傳回來的資料。\n\n因此我們在選單變動時就直接執行ajax call，用HTTP POST去`/cities`所代表controller中的action來執行(也就是`create`這個action)。由於我們指定了`datatype`是script，因此`create`這個action對應到的template就會是javascript，因此就會去執行`create.js.erb`，之後就和上一篇的動作一樣了。\n\n## `create`的回應\n\n因為我們在上面的`datatype`已經指定了`script`，因此controller中的action自動會回應javascript，當然正確的寫法還是要在action中指定回應的格式，如下\n```ruby\n# app/controller/cities_controller.rb\n class CitiesController < ApplicationController\n   def index\n     @countries = Country.all\n     @cities = City.where(country_id: params[:country_id])\n   end\n   def create\n     @cities = City.where(country_id: params[:country_id])\n     respond_to :js\n   end\n end\n```\n\n其中第9行可寫可不寫，他自己會知道要去找`create.js.erb`。\n\n# 整個完整流程\n\n接下來是整個完整流程\n\n1. 使用者在瀏覽器中輸入`http://192.168.1.105:4000/cities`，就是在向後端的伺服器發出GET HTTP。\n2. 伺服器檢查使用者的請求，去查routes是否存在這個請求。\n3. 伺服器發現這個請求對應的是`cities#index`這個action，因此執行這個action中的動作。\n4. 執行`index`這個action之後，把變數代表的值丟到對應的template `index.html.erb`中\n5. `index.html.erb`把變數代表的值換掉其中的變數，成為`index.html`。\n6. `index.html`傳回使用者瀏覽器執行。\n7. 使用者在瀏覽器中從選單選擇國家。\n8. 此時觸發了`'#filter'`這個id的change事件，在使用者的瀏覽器上執行ajax call\n9. 根據ajax call的參數，發現是一個POST事件，因此根據參數值去伺服器端\n10. 伺服器端接到ajax POST的要求，去routes找，發現是`cities_controller.rb`中的`create`這個action。\n11. 此action接收了ajax參數中的`country_id`值，找到城市。\n12. 接下個因為ajax call是要求`script`型態，因此就去找`create.js.erb`，並且把其中的變數換成正常值。\n13. 換完之後，就傳回`create.js`到使用者瀏覽器。\n14. 使用者瀏覽器接收到資料，就執行這個javascript，就是更新`<ul id=\"show_items\">`這個元素內的值。\n\n\n![](/images/jsresponse.gif)\n\n我們可以從上圖中看到從伺服器傳回來的值，就是完整的一段script，並且把其中的html都更新成城市了。\n","tags":["javascript"]},{"title":"Rails單頁選單顯示表單實作(二)","url":"/2017/06/13/remoteTrue/","content":"\n# 前言\n\n在選擇網頁後端語言時，我不斷強調，只要不選擇某些過時的語言都可以，因為網頁語言最重的是在前端，而前端當然就是javascript。不過如果你有幸身在一個大的團隊，前端有人處理了，只要進行後端的開發，那你使用rails提供的jquery library也就夠了。延續上一篇[Rails單頁選單顯示表單實作(一)](http://josh.hu/2017/06/12/samePageForm/)中的作法，當使用者選擇選單中的項目，並且按下送出時，我們把回應action的原來HTTP GET反應，換成HTTP POST，並且把原來回應對應的Template從html換成javascript，再讓這個javascript來更新div而不是整個網頁，直接使用rails內建的ajax call即可。\n\n# 準備工作\n\n你只要有上一篇[Rails單頁選單顯示表單實作(一)](http://josh.hu/2017/06/12/samePageForm/)中準備好的project即可，我們就先切換到新的git branch。\n```shell\ngit checkout -b remotetrue\n```\n\n# 要修改的地方\n\n這邊要修改的地方有幾個\n\n* 原來`index`這個action的view。\n* 在controller中新增一POST的action。\n* 對應到這個POST action的Template本來應該是html，換成javascript。\n\n我們就來看看：\n## 修改cities controller\n\n這邊主要是增加一個`create`的action，因為我們使用了標準的RestFUL的語法，因此對應到`/cities`的POST方法名稱就是`create`。\n\n```ruby\n# app/controllers/cities_controller.rb\nclass CitiesController < ApplicationController\n\n  def index\n    @countries = Country.all\n    @cities = City.where(country_id: params[:country_id])\n  end\n\n  def create\n    @cities = City.where(country_id: params[:country_id])\n  end\n\nend\n```\n\n** 說明**\n\n`create`很簡單，就是從使用者的選單中讀取選中的`country_id`，然後再到model中尋找對應該國家碼的城市。\n\n## 修改index這個view\n\n我們要修改的檔案為`app/view/cities/index.html.erb`，程式碼如下：\n```javascript\n<h2>選擇國家</h2>\n<%= form_tag \"/cities\", remote: true do %>\n  <%= select_tag :country_id, options_from_collection_for_select(@countries, \"id\",\"name\") %>\n  <%= button_tag \"查詢\" %>\n<% end %>\n<ul id=\"show_items\">\n  <%= render @cities %>\n</ul>\n<%= debug(params) if Rails.env.development? %>\n```\n\n** 說明**\n\n這邊最主要的就是第2行中的`remote: true`這個敘述。在rails中，當我們在表單中放入`remote: true`之後，rails就會自動把這個表單在controller中所對應到的action(本例為cities_controller的create)，其所`respond_to`的檔案類型設定為javascript。本來這個action的template應該是`create.html.erb`，但有了`remote: true`之後，對應到的template就變成了`create.js.erb`了。\n\n你當然可以在`create.js.erb`中再度指定新的html，但這就多此一舉了。使用這種機制最常見的作法就是更新原來view中的某一HTML元件。因此我們在上面的程式碼第6行，幫顯示城市的地方加了一個ul的id`show_items`，然後我們只要到`create.js.erb`這個javscript中更新`index.html`中`show_items`這個`<ul>`，你只要記得，我們通常使用javascript啟動ajax call去伺服器端要資料(data)，而不是要頁面(page)，載入速度就會很快，並且可以做到很多動態的效果。\n\n## 新增`create.js.erb`\n\n接下來就是新增一個對應到`create`這個action的template，這邊就是`app/view/cities/create.js.erb`。程式碼如下：\n```javascript\n$('#show_items').html(\"<%= j render @cities %>\");\n```\n\n** 說明 **\n這是一個標準的javascript內嵌rails指令，短短一行，使用了jquery的html函數，而更新的內容，正是我們要求的`render @cities`原來這一塊。\n\n# 整個完整流程\n\n接下來是整個完整流程\n\n1. 使用者在瀏覽器中輸入`http://192.168.1.105:4000/cities`，就是在向後端的伺服器發出GET HTTP。\n2. 伺服器檢查使用者的請求，去查routes是否存在這個請求。\n3. 伺服器發現這個請求對應的是'cities#index`這個action，因此執行這個action中的動作。\n4. 執行`index`這個action之後，把變數代表的值丟到對應的template `index.html.erb`中\n5. `index.html.erb`把變數代表的值換掉其中的變數，成為`index.html`。\n6. `index.html`傳回使用者瀏覽器執行。\n7. 使用者在瀏覽器中從選單選擇國家，並且按下傳送按鈕。\n8. 此時瀏覽器發現使用者發出了HTTP POST的請求，並且因為有`data-remote`這個選項，因此認定這是一個ajax call。\n9. 伺服器端查路由，找HTTP POST對應到的是`cities#create`這個action。\n10. 去執行`cities_controller`中的'create` action。執行之後，把變數代表的值丟到對應的template\n11. 由於是ajax call，因此template不再是html，而是javascript，就是`create.js.erb`。\n12. 把變數代表的值在`create.js.erb`中換成正常值，生成`create.js`。\n13. 把`create.js`傳回使用者的瀏覽器。\n14. 使用者瀏覽器接收到`create.js`，並且在瀏覽器中執行。\n15. 執行的程式碼是`$('#show_items').html('<li>北京</li><li>上海</li><li>廣州</li>');`。因此就直接更新`<ul id=\"show_items\">`這個部分。\n\n![](/images/remotetrue.gif)\n","tags":["javascript"]},{"title":"Rails單頁選單顯示表單實作(一)","url":"/2017/06/12/samePageForm/","content":"# 前言\n\n所謂的單頁表單，就是在同一頁面中，上面有一個選單，下面則是選擇區。當你在選單中選擇項目時，下方的選擇區會根據你在選單中的選項而有所變動。目前單頁應用程式(Single Page Appliation, SPA)非常流行，事實上製作SPA最棒的後端還是node.js，我們以後有機會會提到，在本篇文章中，我們使用rails來看看一個非常簡單的單頁表單作法，先用最簡單的http get的方法來完成，這應該是最簡單的rails應用了。\n\n舉例來說，我們有三個國家，分別是美國、中國、日本，每個國家有自己城市如下：\n\n中國\n  --北京\n  --上海\n  --廣州\n\n日本\n  --東京\n  --北海道\n  --大阪\n\n美國\n  --洛杉磯\n  --紐約\n  --芝加哥\n\n我們要的效果就是在選單中選擇國家，同一頁下方的顯示區就會顯示對應的城市。\n\n\n# 準備環境\n\n作業系統：Mac OS或是Ubuntu 16.04\nruby版本：2.3.0\nrails版本：4.2.6\n請遵照前面文章安裝rvm來管理不同版本的ruby以及gem set。\n\n# 建立專案\n\n```shell\nmkdir updateForm\ncd updateForm\necho 2.3.0 > .ruby-version\necho jobexam > .ruby-gemset\nrails new .\nbundle install\ngit init\n```\n\n其中`.ruby-version`和`.ruby-gemset`是`rvm`管理`ruby`以及`gem set`的專案資源檔，如果目錄中有這兩個檔案，只要進入該目錄，就會自動切換成這兩個檔案指定的`ruby`版本及`gemset`。讀者要注意的是`jobexam`這個`gemset`是之間我已經建立好的。讀者可以自行建立你的`gemset`，只要確定你的`rails`版本為`4.2.6`即可，之後用`rails new .`建立專案，`bundle install`安裝需要的`gem`。\n\n# 建立model及準備樣本資料\n\n我們需要兩個model，一個是國家，一個是城市，輸入下面指令建立\n\n```shell\nrails g model country name:string\nrails g model city name:string country:reference\nrake db:migrate\n```\n\n## 說明\n\n首先建立一個model名稱為`country`，只有一個自訂屬性`name`即國家名稱。接下來建立另一個model為`city`，有一個自訂屬性`name`為城市名稱之為，我們要讓系統知道這個model是`country`這個model的子類別，即**一個`country`可以有多個`cities`**，因此加上`country:reference`。這句話的意思其實就是在`city`這個model中加上`belongs_to :country`。\n\n另外我們要到`country`這個model中手動加入擁有多個`cities`的敘述，打開`app/models/country.rb`輸入如下：\n```ruby\n# app/model/country.rb\nclass Country < ApplicationRecord\n  has_many :cities\nend\n```\n\n你也可以打開`app/models/city.rb`來看，由於使用了`country:reference`的參數來建立model，因此已經會預設有`belongs_to :country`了。\n```ruby\n# app/model/city.rb\nclass City < ApplicationRecord\n  belongs_to :country\nend \n```\n\n\n## 準備樣本資料\n\n開啟`db/seeds.rb`，並且輸入資料如下：\n```ruby\n# db/seeds.rb\n\nCountry.delete_all\n\nCountry.create!(\n  { id: 1,\n    name: \"美國\"\n  }\n)\nCountry.create!(\n  { id: 2,\n    name: \"中國\"\n  }\n)\nCountry.create!(\n  { id: 3,\n    name: \"日本\"\n  }\n)\n\nCity.delete_all\n\nCity.create!(\n  { id: 1,\n    name: \"洛杉磯\",\n    country_id: 1\n  }\n)\nCity.create!(\n  { id: 2,\n    name: \"紐約\",\n    country_id: 1\n  }\n)\nCity.create!(\n  { id: 3,\n    name: \"芝加哥\",\n    country_id: 1\n  }\n)\nCity.create!(\n  { id: 4,\n    name: \"北京\",\n    country_id: 2\n  }\n)\nCity.create!(\n  { id: 5,\n    name: \"上海\",\n    country_id: 2\n  }\n)\nCity.create!(\n  { id: 6,\n    name: \"廣州\",\n    country_id: 2\n  }\n)\nCity.create!(\n  { id: 7,\n    name: \"東京\",\n    country_id: 3\n  }\n)\nCity.create!(\n  { id: 8,\n    name: \"北海道\",\n    country_id: 3\n  }\n)\nCity.create!(\n  { id: 9,\n    name: \"大阪\",\n    country_id: 3\n  }\n)\n```\n\n# 建立Controllers\n\n接下來要建立Controllers。由於我們只要顯示城市，因此只要建立`cities controller`以及在`config/routes.rb`中對應的路由。先建立controller。\n```\nrails g controller cities index create\n```\n\n接下來修改路由如下：\n```ruby\n# config/routes.rb\nRails.application.routes.draw do\n  resources :cities, only: [:index, :create]\nend\n```\n\n上面的路由中，我們使用標準的RestFUL資源型式，但由於只需要用到`GET/POST cities`，因此只用兩個`actions`即可。接下來就可以編輯controller了，如下：\n```ruby\n# app/controllers/cities_controller.rb\nclass CitiesController < ApplicationController\n  def index\n    @countries = Country.all\n    @cities = City.where(country_id: params[:country_id])\n  end\nend\n```\n\n## 說明：\n\n其中先將所有的國家讀到`@countries`這個變數中給選單用，然後設定`@cities`則是使用者選取選單之後，把國家代碼傳回這個`action`，再去資料庫取出符合國家代碼的城市。\n\n# view\n\nView有兩個部分，一個是`index`這個`action`對應的template，即`app/view/cities/index.html.erb`，另一個則是單獨要列出所有城市的`partial`。如下：\n\n```html\n<h2>選擇國家</h2>\n<%= form_tag \"/cities\" ,method: :get do %>\n  <%= select_tag :country_id, options_from_collection_for_select(@countries, \"id\",\"name\")%>\n  <%= button_tag \"查詢\" %>\n<% end %>\n<ul>\n  <%= render @cities %>\n</ul>\n<%= debug(params) if Rails.env.development? %>\n```\n\n## 說明\n\n第2行這邊不使用`form_for`而使用`form_tag`是為了簡化。首先要做的就是加上`method: :get`表示這個表單是要用`GET`，因此在`RestFUL`的動作中就還是會回到`cities#index`這個`action`中，因此我們的controller就沒有對應到`POST`的`create`這個`action`。\n\n第3行使用了標準的`select_tag`，並且使用了`options_from_collection`把`@countries`放入`collection`中成為選單，並且以`id`為`html`的`value`，`name`為顯示出來的值。最後第4行放上一個按鈕送出。**注意**：在rails中，輸入表單一定要有一個送出的機制，因此這邊一定要放入一個`button_tag`，才會產生RestFUL的GET或POST動作。\n\n接下來是第7行的`<%= render @cities %>`。這句敘述表示要將`@cities`這整個collection丟到一個叫做`_city.html.erb`的`partial`來顯示，而且在`_city.html.erb`中，你不需要使用`@cities.each do |city|`的迴圈來執行，這種型式的`partial`會自動把整個`@cities`iterate一遍。因此我們要建立這個`partial`，檔案為`app/view/cities/_city.html.erb`\n\n```html\n<li><%= city.name %></li>\n```\n\n\n接下來先將這個版本的程式commit，輸入`git add .`以及`git commit -am \"init\"`，然後直接啟動，輸入`rails s -b 0.0.0.0 -p 3001`，就可以登入看結果，請到該主機上輸入`http://localhost:3001/cities/`\n\n![](/images/result.gif)\n\n\n# 待改進處：\n\n1.執行結果使用get到原方法，因此選單中的選項會回到最原始的預設值美國\n2.使用get表單，因此雖然看起來是在同一頁，其實是有換頁，正確應該用ajax，就是只更新顯示城市的地方而不要換頁。\n3.選擇國家後，應後就直接顯示城市，而不需要一個按鈕。\n\n# 整個完整流程\n\n接下來是整個完整流程\n\n1. 使用者在瀏覽器中輸入`http://192.168.1.105:4000/cities`，就是在向後端的伺服器發出GET HTTP。\n2. 伺服器檢查使用者的請求，去查routes是否存在這個請求。\n3. 伺服器發現這個請求對應的是'cities#index`這個action，因此執行這個action中的動作。\n4. 執行`index`這個action之後，把變數代表的值丟到對應的template `index.html.erb`中\n5. `index.html.erb`把變數代表的值換掉其中的變數，成為`index.html`。\n6. `index.html`傳回使用者瀏覽器執行。\n7. 使用者從`index.html`中的選單選擇，並且按下按鈕。\n8. 重複2-6的動作。\n\n","tags":["javascript"]},{"title":"對Mac的誤解之一：Mac比PC貴？","url":"/2017/05/23/MacCheaper/","content":"## Mac比PC貴\n\n在購買電腦時，大家都覺得Mac很酷，很潮，但也比PC貴，因此一般預算買家會直接選擇安裝Windows的PC。事實上，Mac早就使用和PC一樣的x86架構，照道理說，硬體成本應該是和一般的PC差不多的。\n\nMac真的比PC貴嗎？這句話正確的說法，應該是**「PC使用的硬體價格範圍較廣」**。換句話說，你可以用很便宜的價格買到規格很爛的PC，但對應到Mac卻沒有廉價的版本。因為Mac的硬體再爛也是從相當不錯的規格起跳，如SSD、較高階的CPU, 因此比較最入門的PC和Mac，感覺似乎Mac比較貴，但事實上是如此嗎？\n\n### 低價版產品\n\n你可以隨便找一台14吋的PC，售價2萬出頭，規格如下：\n\n> 處理器：Intel Core i5-6200U \n> 記憶體：4GB DDR4 2133 \n> 硬碟：500GB (7200rpm) \n> 顯示晶片：NVIDIA GeForce 920M 2G獨顯 \n> ** NT$22,900 **\n\n![](asuscheap.jpg)\n\n但是最便宜的Mac也有8G的記憶體，128GB的SSD硬碟，起跳就3萬多，\n\n> 1.6GHz 雙核心 Intel Core i5 處理器\n> Turbo Boost 可達 2.7GHz\n> Intel HD Graphics 6000\n> 8GB 記憶體\n> 128GB PCIe 快閃儲存\n> **  NT$31,900 **\n\n![](mbacheap.jpg)\n\n並不是PC比較便宜，而是Mac沒有這麼低階的產品，因為蘋果根本不在乎低階市場，要提供讓人基本滿意的使用體驗，蘋果認為4GB的記憶體和500GB的普通硬碟根本做不到。\n\n\n### 正常版產品\n\n一台較好用的PC，基本上規格如下：\n\n> Intel Core i5-7200U , 3.1GHz\n> LPDDR3 8G(on board) 無法擴充\n> 512G M.2 SSD\n> Intel® HD graphics 620\n> ** NT$37,900 **\n\n![](asus.jpg)\n\n對應到蘋果產品的Mac，基本上就是MacBook Air了。我們就以可以流暢用來寫程式、做3D，影音轉檔的規格來說，那就是13吋的MacBook Air，其規格如下：\n\n> 1.6GHz 雙核心 Intel Core i5 處理器\n> Turbo Boost 可達 2.7GHz\n> Intel HD Graphics 6000\n> 8GB 記憶體\n> 256GB PCIe 快閃儲存\n> ** NT$38,900 **\n\n![](macbookair.jpg)\n\n可以看到當規格拉到稍好(就是用起來較順暢的正常使用)，Mac和PC之間的價格就**差不多一樣了**，當然前題是上述兩款電腦的基本硬體是差不多的。\n\n### 高階版產品\n\n最高階的Mac就是MacBook Pro 15，目前售價是92990台幣，對應到的PC是Dell Precision M5510_8，售價是92000台幣。PC多了一台1TB的傳統硬碟，但SSD比較小，是256GB(Mac是512GB)，另外PC的解析度是4K，Mac是3K，其它規格大同小異(圖型加速卡的速度差距不大，參考這篇https://hardrealm.com/en/video/Radeon-Pro-455-vs-Quadro-M1000M)\n\n因此看起來當PC和Mac的規格越來越好時，價格就差不多了。\n![](macexpensive.jpg)\n![](dellexpensive.jpg)\n\n\n### 看不到的成本\n\nPC有很多隱藏成本，隨便列出兩個你就知道了。\n\n* Microsoft Office：4000元(家用版)或7700元(中小企業版)\n* 防毒軟體：約2000元\n\n在Mac上，有現成的Apple的Office類軟體，是免費的，另外Mac上是不需要防毒軟體的。這樣算一下，一套可用又安全的Windows 10，在同樣的硬體規格下，是比Mac貴上5000-8000元。當然如果你說不用安裝防毒軟體，也不需要買Office，那我也就不多說了。\n\n### 結論\n\n很多人在購買電腦時，總覺得PC物超所值，Mac比較貴。但就不算擁有成本了，購買成本的PC也沒有比較便宜。事實上硬體工業目前製作成本已經大同小異了，再加上Mac早就使用了x86架構，兩者硬體元件差不多，當然成本也會一樣。下次當你要買電腦時，如果目標是中高階的產品，可以考慮買台Mac(也可以安裝Windows)。\n\n","tags":["Windows"]},{"title":"電腦的選擇(硬體篇)","url":"/2017/05/22/ComputerHardware/","content":"TL;DR:\n\n* 你需要至少兩台實體機(開發機和伺服器)和一台雲端主機\n* 開發機用筆電，伺服器用筆電或桌機都行  \n* 開發機：16GB記憶體、多核心CPU、三螢幕\n* 伺服器：16GB記憶體、多核心CPU\n* 雲端主機用Google Compute Engine或阿里雲，** 不要用Heroku **\n* 預算夠可再組一台NAS機(RAID1)備份資料(12GB記憶體，雙核心CPU, 3TB RAID1)\n<!--more-->\n\n## 硬體的重要性\n\n很多人覺得隨便挑一台電腦就可以開始學習IT，這個觀念對初學者看似沒什麼大問題。但隨著學習東西越來越多，需要的軟體、工具、套件越來越複雜，你的環境的嚴謹性就越來越重要了。 很少有文章探討電腦選擇的問題，我們就來看看。\n\n## 需要幾台電腦？\n\n** 至少三台 **\n\n* 開發機\n* 伺服器\n* 雲端主機\n\n** 如果預算足夠 **\n\n* Linux NAS來當儲存伺服器\n* 一般的PC作為Bare Metal虛擬化主機\n\n## 桌機或筆電？\n\n* 開發機用筆電，因為需要DEMO給客戶看，用Mac為主\n* 伺服器用筆電或桌機都行，用PC\n* 雲端主機選擇Google Compute Engine或阿里雲，** 不要用Heroku **\n\n## Mac或PC？\n\n* 開發機最好用Mac，次要選擇為PC安裝Linux Mint\n* 伺服器用PC安裝Ubuntu 16.04(或下一個LTS版本)\n* 雲端主機安裝Ubuntu 16.04(或下一個LTS版本)\n\n## 開發機說明\n\n開發機非常重要，和你日夜相伴，多花一點錢在這台機器上面，會給你帶來更大的回報！選擇開發機的重點如下：\n\n** 1. 首選Mac，次選Linux Minx **\n\nMac買來就直接可以開工了，Linux一定是安裝在PC上，視你購買的硬體，可能會有驅動程式或相容性、多螢幕顯示的問題。\n\n\n** 2. 16G以上的記憶體 **\n\n目前記憶體便宜的要死，不差這幾百元。有了16GB以上的記憶體，你可以大方開好幾個虛擬機來測試`Hadoop`、`Spark`、`ElasticSearch`等需要叢集的環境。這個錢別省。目前Mac的筆電最多只有16GB(2017年5月)，聽說下一代就可以加到32GB，到時我一定加上去！\n\n** 3. 多核心CPU **\n\n只要你買正常電腦，不要特別去挑很便宜的配備，都會是多核心CPU。\n\n** 4. SSD固態硬碟 **\n\nSSD主要是快，事實上電腦速度慢最大的元兇通常就是硬碟。不要想什麼TB的SATA機器硬碟，慢的要死，就直上SSD。至少要256GB，能買到512GB最好。不要想用什麼混合碟，就直接買SSD就行。如果你常跑`vagrant`或`docker`，最好是512GB以上。\n\n** 5. 能接至少兩個外接螢幕 **\n\n相信我，三個螢幕才是主流，一個NB的螢幕加兩個外接，是至少的，我常常用一個NB的螢幕加三個外接才覺得夠用。你不會想把時間花在到處尋找開啟的視窗上的。\n\n![](3.jpg)\n![](3desktop.jpg)\n\n** 6. 購買推薦排行 **\n\n(1) MacBook Pro 15吋 16GB\n(2) Macbook Pro 13吋 16GB\n(3) Dell Precision M5510_8 15吋，16GB至少要有HDMI及一個VGA外接埠\n\n## 伺服器說明\n\n開發機是你寫程式的前端，伺服器則算是你的遊樂場或是實驗室。這個電腦不需要太好，因為隨時可能重裝，但如果你需要執行Big Data類的應用，如`vagrant`, `docker`, `hadoop`, `spark`，就需要多一點記憶體和快速的SSD硬碟。當然4核心的CPU是不可少的。\n\n** 1. 用PC不要用Mac **\n\n因為要安裝Linux，因此用PC即可，用Mac有點浪費了。最好使用標準的硬體設備，例如不要用奇怪的顯示卡，以免Linux找不到驅動程式。\n\n** 2. 非必要可用桌機 **\n\n如果不需要常常帶到客戶那邊做多機器DEMO，這台電腦應該是放在的工作場所的，因此不需要是筆電。另外用桌機的好處就是可以較便宜，安裝更多的記憶體，多片網路卡做trunking加速等等。\n\n** 3. 多核心CPU **\n\n理由同開發機。\n\n** 4. 可以考慮用RAID0的SSD固態硬碟 **\n\n速度快，容量大，又可以練習Linux下的mdadm，如果常常跑虛擬機或big data應用更能感受速度上優勢。\n\n** 5. 購買推薦排行 **\n\n(1) 一般的PC，32GB記憶體，4核心CPU，兩顆256GB SSD組合成的RAID 0。 \n(2) 一般的NB，16GB記憶體體，256GB SSD硬碟\n\n## 雲端主機說明\n\n為什麼要申請雲端主機是另一篇文章的重點，這邊只推薦大家適合的雲端主機廠商。\n\n** 1. Google Compute Engine **\n\n從中國大陸以外的地方進入速度快，售價合理，提供功能多，第一次使用有300美元的免費額度，怎麼看都方便。我最喜歡的地方就是提供了Linux或Mac下的指令。在全世界各地都有機房(台灣在彰濱工業區)，如果你所在的國家或地區能正常使用Google，這是第一選擇。\n\n** 2. 阿里雲 **\n\n如果你在中國大陸，無法正常使用Google的服務，阿里雲是我最推薦的服務。一個月幾十元就有一個公網主機，服務也多，網路速度快，提供的東西都很穩定，並且支援多個主流的Linux Distros，有意在中國大陸發展，阿里雲是你一定要熟悉的產品。\n\n** 3. 為什麼不要用Heroku? **\n\n網路上的教學最愛教大家把網站部署到Heroku上面，其重點不外乎是免費，有現成的DB，可以綁定自己的域名等等，但Heroku最大的問題，就是他是一個PAAS，是只有提供網頁及資料庫服務的雲端供應商，不是一個完整的雲端運算平台提供商，你能學到的東西不但少，而且是Heroku專用的，花時間在這上面， 只是為了一個月幾百元的免費功能，想想實在是划不來。你真的在乎那一個月幾百元的Google/阿里雲主機費用嗎？有一個完整的主機功能，能在上面佈署完整的服務，玩大數據，玩NoSQL的完整雲端主機，怎麼樣都比只有其5%功能不到Heroku的主機有用。\n\n為了使用Heroku的免費功能，你要學習好多Heroku的專屬指令和工具，與其花時間在這專屬的平台上，為何不學習完整、開放，放諸任何平台皆可使用的功能呢？所以就一句老話：** 不要花時間在Heroku上面！！ **\n\n## NAS主機說明\n\n備份是非常重要的事。努力很久的東西就不見了，任誰都會x的要死。\n\n** 1. 不要買現成的NAS產品 **\n\n\n很多人會買專業的NAS來備份，但我不建議，因為他們用的硬體實在不怎麼樣，你花一半不到的價錢，自己安裝一個Linux就搞定所有的事，而且還能練習用Linux自建RAID、安裝多片網路卡做加速，省錢又可以搞懂Linux的儲存，何樂而不為？\n\n** 2. 使用Linux內建的軟體RAID，不要用主機板上的RAID **\n\n主機板上的RAID是假的，和真正的RAID卡的效能和功能差很多。如果你用主機板內建的RAID功能，建立的磁碟陣列在轉移機器時很可能就不能用了。但使用Linux的軟體RAID，不管是換電腦，或是RAID硬碟壞了要重建，一個指令就搞定，方便又有相容性，速度也一樣快。\n\n** 3. 做RAID1即可 **\n\n買兩顆3TB的一般SATA硬碟及RAID1備份重要資料即可，不用想什麼RAID0(沒意義，這是備份機不求速度)，不用想RAID5(個人RAID1很夠了，RAID5至少要三顆硬碟，不會省多少空間)。\n\n** 4. 用SAMBA給Windows，NFS給其它Linux **\n\n儘量用NFS分享，但你的工作環境如果有Windows，就要用SAMBA。本站之後會有詳細的文章說明這部分 \n\n** 5. 這台機器可用來執行常用的虛擬機工作 **\n\n筆者在這台機器上安裝了12GB的記憶體，使用雙核心的廉價CPU，啟動兩個VM，一個是4GB的Windows 7用來下載，另一個是256MB的Linux做為內網的DNS。\n\n** 6. 可做為ssh reverse tunnel的內網入口 **\n\n有時你需要從外面ssh回到家中的內網，此時可以用這台來做ssh反向通道的入口，再從這台連線到內網中其它的電腦，我們會在本站稍後有完整的說明文章。\n","tags":["ssh"]},{"title":"Windows？Mac？Linux？我要用什麼電腦？","url":"/2017/05/18/untitled-1495120237176/","content":"\n### TL;DR: \n第一志願選擇MacBook Pro，第二志願選擇一般筆電裝Linux Mint\n\n## 用什麼電腦重要嗎？\n\n一個專業IT人的電腦重要嗎？好像沒人認真討論過這個問題，似乎從小就用Windows，也習慣在Windows上做所有的事情，當一切都這麼理所當然時，我卻必須在這邊鄭重的說：\n\n **要成為專業的IT高手，儘早離開Windows！**。\n\n有這麼嚴重嗎？下面是我的說明：\n\n<!--more-->\n\n## 你的世界應該都是指令\n\n從DOS開始學電腦的人應該無法忘記那麻煩的指令。\n\n## 使用指令的好處\n\n* 遠端操作(SSH)\n* 可自動化\n* 可串接多個指令\n* 效率高速度快\n* 能100%控制電腦\n* 能做到GUI做不到的事\n* 能用程式語言控制\n* 能編輯\n* 能成為服務\n* 能讓你控制最底層的硬體到最上層的介面\n* 省去滑鼠移來移去的麻煩及人為介入\n\n## 使用圖型介面的必要性\n\n## 為什麼不能用圖型介面的Linux？\n\n## 用Mac有什麼好處？\n\n##  對Windows的誤思\n\n前面說過，越早離開Windows，你的IT專業人之路會越好走。很多人一定不以為然，想說都用了Windows一輩子了，整個Windows系統都摸的滾瓜爛熟，什麼軟體都裝的上去，什麼程式也開發過，憑什麼說Windows不好？\n\n### Windows並沒有比較好用\n\nWindows好用是你習慣了而已，而且你也一直在為了它，不斷改變你的使用習慣。\n\n事實上Windows從95到7，這20年在介面上根本沒有變化，但是當Windows 7變成Windows 8時，只是把一個開始功能表拿掉了，你就氣的哀哀叫對吧。當時的你只有兩個選擇，一個是繼續用Windows 7(和我一樣)，另一個就是改變自己的使用習慣來適應Windows 8。\n\n我就是無法從Windows 7變成Windows 8，所以就一直用Windows 7，當然我就得忍受\n\n1. 不支援的新硬體\n2. 慢的要死的USB 3.0\n3. 隨時會入侵的病毒\n4. 隨時會中止的微軟更新\n\n說實話，新一代作業系統的視窗介面都來自於Palo Alto，就滑鼠點，拖拉視窗，x〇-的圖案，用起來都一樣，沒有習不習慣的問題。既然你能改變使用習慣去適應新的作業系統(7到8)，如果能讓你成長，變成更強的高手，你何苦不改變使用習慣到一個更適合IT專業人士的作業系統(Linux或Mac)呢？\n\n所以如果覺得換到Mac或Linux是Windows比較好用的原因，那麼下次Windows再改版時，你再考慮覺得值不值得，因為Windows根本沒有比較好用。\n\n### 在虛擬機中安裝Linux\n\n我相信有90%需要使用Linux的人，會在Windows中安裝VMware Workstation或Virtual Box，再在裏面安裝Linux。設定好分享資料夾之後，照樣可以操作需要的Linux功能。\n\n不，並不好。有一個叫`vagrant`的東西，會讓你自動化的功力向上提升三個檔次。`vagrant`使用指令直接管理虛擬機，我們會有一系列的教學範例。\n\n你如果在虛擬機中安裝Linux，再在這個Linux中安裝`vagrant`，就得在這個虛擬機中安裝Virtual Box，這樣稱之為巢狀的虛擬化(Nested Virtualization)，就是\"虛擬機中的虛擬機\"，有點像Inception電影中的\"夢中夢\"。\n\n這樣的架構，速度慢到死人就不說了，事實上很多功能本就無法執行。\n\n另外如果你還在用VMware Workstation手動安裝虛擬機，那你離自動化的腳步應該是越來越遠了。\n\n### Windows並沒有比較便宜\n\n是的，一台PC的筆電大約兩萬多就有了，Mac同配備的要快四萬，大約是一倍半的價錢。聽起來是PC便宜多了，是嗎？我們來算算帳。\n\n作業系統：Windows 10 \t\t\t\tMac OS\n防毒軟體：2000元上下\t\t  \t\t不用\n防火牆：\t2000元上下\t\t\t\t\t不用\noffice：\t\t5、6千元\t\t\t\t\t\t不用(或800元)\n售後服務\t\n\n#### 作業系統\n\nWindows 10當然要錢，如果你想要遠端桌面連入的功能，你就要買專業版，如果你需要加入AD，你也要買企業版，當然你用盜版的話，就要小心病毒，或是有人檢舉你賺獎金。\n\nmac os不用錢\n\n#### 防毒軟體/防火牆軟體\n\nWannaCry還記得吧？你當然可以用免費的Windows Defender，問題是你放心嗎？至少買個卡巴斯基，小紅傘，avast等防毒軟體吧？1千到5千不等。\n\n別忘了除了病毒還有一堆想衝到你電腦中，啟動你的WebCam偷看你私生活的駭客們。別忘了裝一個防火牆軟體。是有Windows防火牆，但已經證明不安全的東西少用。\n\nmac os上沒有病毒，防火牆也是內建的\n                  \n#### office軟體\n\noffice是微軟的搖錢樹，你一定要買，不買就失去買電腦的意義了。\n\nmac上的辦公軟體是免費的，如果你要用微軟的office，900元。\n\n#### 總結\n\nmac的持有成本加購入成本比Windows低，不要以為一開始付出的錢才是錢。這只是中階的pc和mac的對比，高階的pc和mac對比，同樣配備的兩者，pc購入成本甚至比mac還要高。\n\n### Mac和Windows大車拼\n\n##### 安裝原生Mac OS\n\n蘋果：YES\nPC：NO\n\n不要和我說黑蘋果，先不談合法性，黑蘋果光驅動程式就搞死你。另外多螢幕、USB裝置、網路卡，顯示介面卡，會讓你氣的不要不要的。你與其花這些時間，不如買一台真正的Mac。\n\n##### 安裝原生Windows 10\n\n蘋果：YES\nPC：YES\n\n兩個都可以，當然你要擁有合法的Windows 10授權。\n\n##### 安裝Windows/Mac OS雙系統\n\n蘋果：NO\nPC：YES\n\nPC黑蘋果就不行了，雙系統更不行。Mac原生支援雙系統或多系統。\n\n#####  安裝原生Linux\n\n蘋果：YES\nPC：YES\n\n\nPC可以，Mac當然可以，參考這個網址和這個網址。\n\n\n\n\n\n\n\n"},{"title":"重作博主","url":"/2017/05/18/untitled-1495038454953/","content":"\nTL;DR: 分享Google、FB、Yahoo!頂尖工程師的馬步及思路\n\n## 重作博主\n\n這次重新寫博，花了五年時間積累，還是想和大家分享技術之路，也請大家繼續指教。\n\n### 虛擬先生的中斷\n\n我在2011年寫了一本VMware的書的前後，也開了一個blog叫做「虛擬先生」。中間記錄了許多和VMware相關的知識。當時除了記錄使用的過程之外，也想讓讀者和我之間有一個溝通的管道。「虛擬先生」使用的是標準的Wordpress，也租了雲端主機安裝，算是第一次寫blog。\n\n<!--more-->\n\n但隨著使用開源項目的機會越來越多，相對VMware也就越來越少接觸，再加上重心幾乎都投入雲端、Big Data等技術，這幾年工作也轉到DevOps上，虛擬先生在2013年後就完全沒更新，2014年也就關站了。\n\n### 為什麼又要寫？\n\n由於工作的關係，這幾年來慢慢和一些新創公司的頂尖工程師有越來越多的合作機會。除了他們絕頂聰明的腦袋讓我常常覺得跟不上之外，我發現這些頂尖的工程師和普通工程師最大的不同，就是他們**基本功夫紮實地讓人汗顏**。他們所做的所有事情，每一個細節，每一個步驟，都是穩紮穩打，並且有絕對正確的道理，在日積月累之後，和一般工程師的差距自然就拉開了。\n\n在從頭開始培養工程師，一直到能獨立作業，甚至是帶領團隊的完整cycle中，我慢慢發現這是一個可以re-produce的過程。雖然知識面又廣又深，但點點滴滴開始未嚐不可。\n\n這個新開的blog，目的就是想把這整個步驟付諸實現。\n\n這個blog，將會是從最基礎的面向探討電腦工程的學習之路，會有哲學思想(例如：學習電腦從卡關開始)、有最基礎，但卻沒有人認真探討過的問題(例如：為什麼要用蘋果而不用Windows)；有語言的選擇(例如：選一個最適合你的電腦程式語言)；有工具(例如：ansible的使用大全)等等。林林總總，大大小小的事都會最詳細說明。\n\n### 寫的方式\n\n學電腦最怕就是找不到資料，但更怕就是找到的資料照著做，根本做不出來！我搞不懂為什麼會有人寫這種教程，浪費自己的時間寫一些沒用的東西不說，浪費更多人的時間照著做一些永遠做不出來的事！\n\n我不想當這種人，因此會儘量把過程寫的一清二楚。但每個人的環境不一樣，因此我會列出最完整的環境，並且會附上完整的程式碼放到github上，至少保證用我的環境是一定做的出來的。因此力求完整清楚，會是一貫的寫作風格。\n\n### 當某個內容夠多時\n\n當某一個主題的內容經過系統化整理，並且有一定的份量時，我會把這些內容用gitbook的方式發佈，這樣是希望大家可以專心地、系統化地學習一個完整的領域。\n\n### 這個blog的樣式\n\n這個blog使用hexo+github的靜態網頁製作，因此速度快，容易維護，但因為我對hexo不熟，因此會花一段時間研究，隨著我文章的不斷更新，這個blog也會越來越好用，越來越漂亮。\n\n至於其它常常會提到的重點，我會放到一個專門的about來說明。\n\n"}]